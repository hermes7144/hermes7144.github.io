---
title: 리액트 - 렌더링하고 커밋하기, 스냅샷으로서의 state
date: 2024-03-04 00:00:00 +09:00
categories: [프론트엔드, 리액트]
tags: [프론트엔드, 리액트]
---

## Rendering and Commit

주방에서 요리사가 컴포넌트를 재료로 요리를 한다고 상상. 이 시나리오에서 React는 고객의 요청을 받고 주문을 가져오는 웨이터. UI를 요청하고 제공하는 세 가지 단계

1. 렌더링 **트리거**(손님의 주문을 주방으로 전달)
2. 컴포넌트 **렌더링**(주방에서 주문받기)
3. DOM에 **커밋**(테이블에 주문한 요리 내놓기)

### Step 1: 렌더링을 트리거합니다.

1.  컴포넌트의 **첫 렌더링인 경우**
2.  컴포넌트의 **state**(또는 상위 요소 중 하나)가 업데이트된 경우

컴포넌트가 처음 렌더링되면 set (설정자) 함수로 state를 업데이트하여 추가 렌더링을 트리거할 수 있습니다. 컴포넌트의 state를 업데이트하면 자동으로 렌더링이 대기열에 추가됩니다.

### Step 2: React가 컴포넌트를 렌더링합니다.

- 첫 렌더링에서 React는 루트 컴포넌트를 호출합니다.
- 이후 렌더링에서 React는 state 업데이트에 의해 렌더링이 발동된 함수 컴포넌트를 호출합니다.

이 과정은 재귀적입니다: 업데이트된 컴포넌트가 다른 컴포넌트를 반환하면 React는 다음으로 해당 컴포넌트도 컴포넌트를 반환하면 반환된 컴포넌트를 다음에 렌더링하는 방식입니다. 중첩된 컴포넌트가 더 이상 없고 React가 화면에 표시되어야 하는 내용을 정확히 알 때까지 이 단계는 계속됩니다.

- **첫 렌더링을 하는 동안** DOM노드를 생성합니다.
- **리렌더링하는 동안** React는 이전 렌더링 이후 변경된 속성을 계산합니다. 다음 단계인 커밋 단계까지는 해당 정보로 아무런 작업도 수행하지 않습니다.

### Step 3: React가 DOM에 변경사항을 커밋

- **초기 렌더링의 경우** React는 `appendChild()` DOM API를 사용하여 생성한 모든 DOM 노드를 화면에 표시합니다.
- **리렌더링의 경우** React는 필요한 최소한의 작업(렌더링하는 동안 계산된 것!)을 적용하여 DOM이 최신 렌더링과 일치하도록 합니다.

**React는 렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경합니다.**

- 렌더링 결과가 이전과 같으면 React는 DOM을 건드리지 않습니다.

## 스냅샷으로서의 state

### state를 설정하면 렌더링이 트리거됩니다.

### 렌더링은 그 시점의 스냅샷을 찍습니다.

"렌더링"이란 React가 컴포넌트, 즉, 함수를 호출한다는 뜻입니다. 해당 함수에서 반환하는 JSX는 시간상 UI의 스냅샷과 같습니다. prop, 이벤트 핸들러, 로컬 변수는 모두 **렌더링 당시의 state를 사용해** 계산됩니다.

사진이나 동영상 프레임과 달리 반환하는 UI '스냅샷'은 대화형입니다. 여기에는 input에 대한 응답으로 어떤 일이 일어날지 지정하는 이벤트 핸들러와 같은 로직이 포함됩니다. 그러면 React는 이 스냅샷과 일치하도록 화면을 업데이트하고 이벤트 핸들러를 연결합니다. 결과적으로 버튼을 누르면 JSX에서 클릭 핸들러가 발동됩니다.

React가 컴포넌트를 다시 렌더링할 때:

1. React가 함수를 다시 호출합니다.
2. 함수가 새로운 JSX 스냅샷을 반환합니다.
3. 그러면 React가 반환한 스냅샷과 일치하도록 화면을 업데이트합니다.

![alt text](https://res.cloudinary.com/dud0yfarc/image/upload/v1709526406/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-03-04_132300_ubrne4.png)

컴포넌트 메모리로서 state는 함수가 반환된 후 사라지는 일반 변수와 다릅니다. state는 실제로 함수 외부에 마치 선반에 있는 것처럼 React 자체에 "존재"합니다. React가 컴포넌트를 호출하면 특정 렌더링에 대한 state의 스냅샷을 제공합니다. 컴포넌트는 **해당 렌더링의 state 값을 사용해** 계산된 새로운 props 세트와 이벤트 핸들러가 포함된 UI의 스냅샷을 JSX에 반환됩니다!

![alt text](https://res.cloudinary.com/dud0yfarc/image/upload/v1709526728/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2024-03-04_133153_lk6xnz.png)

**state를 설정하면 다음 렌더링에 대해서만 변경됩니다.** 첫 번째 렌더링에서 `number`은 0입니다. 따라서 해당 렌더링의 `onClick` 핸들러에서 `setNumber(number + 1)`가 호출된 후에도 `number` 값은 여전히 0입니다.

```
<button onClick={() => {
  setNumber(number + 1);
  setNumber(number + 1);
  setNumber(number + 1);
}}>+3</button>
```

이 버튼의 클릭 핸들러가 React에게 지시하는 작업은 다음과 같습니다.

1. setNumber(number + 1): number는 0이므로 setNumber(0 + 1)입니다.

- React는 다음 렌더링에서 number를 1로 변경할 준비를 합니다.

2. setNumber(number + 1): number는 0이므로 setNumber(0 + 1)입니다.

- React는 다음 렌더링에서 number를 1로 변경할 준비를 합니다.

3. setNumber(number + 1): number는 0이므로 setNumber(0 + 1)입니다.

- React는 다음 렌더링에서 number를 1로 변경할 준비를 합니다.

setNumber(number + 1)를 세 번 호출했지만, 이 렌더링에서 이벤트 핸들러의 number는 항상 `0`이므로 state를 1로 세 번 설정했습니다. 이것이 이벤트 핸들러가 완료된 후 React가 컴포넌트안의 number를 3이 아닌 1로 다시 렌더링하는 이유입니다.

**state 변수의 값은** 이벤트 핸들러의 코드가 비동기적이더라도 **렌더링 내에서 절대 변경되지 않습니다.** 해당 렌더링의 onClick 내에서, setNumber(number + 5)가 호출된 후에도 number의 값은 계속 0입니다. 이 값은 컴포넌트를 호출해 React가 "스냅샷을 찍을" 때 "고정"된 값입니다.

## 여러 state 업데이트를 큐에 담기

### state 업데이트 일괄처리

setNumber(number + 1) 를 세 번 호출하므로 “+3” 버튼을 클릭하면 세 번 증가할 것으로 예상할 수 있습니다:

```
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}
```

각 렌더링의 state 값은 고정되어 있으므로, 첫번째 렌더링의 이벤트 핸들러의 number 값은 setNumber(1)을 몇 번 호출하든 항상 0입이다.

**React는 state 업데이트를 하기 전에 이벤트 핸들러의 모든 코드가 실행될 때까지 기다립니다.** 이 때문에 리렌더링은 모든 `setNumber()` 호출이 완료된 이후에만 일어납니다.

이는 음식점에서 주문을 받는 웨이터와 비슷하다. 주문이 끝날 때까지 기다렸다가 주문을 변경하고, 심지어 테이블에 있는 다른 사람의 주문도 받습니다.

이렇게 하면 너무 많은 리렌더링을 트리거하지 않아도 여러 컴포넌트에서 나온 다수의 state 변수를 업데이트할 수 있습니다. 하지만 이건 이벤트 핸들러와 그 안에 있는 코드가 완료될 때까지 UI가 업데이트되지 않는다는 의미입니다.

### 다음 렌더링 전에 동일한 state 변수를 여러 번 업데이트하기

다음 렌더링 전에 동일한 state 변수를 여러 번 업데이트 하고 싶다면 `setNumber(number +1)`와 같은 다음 state 값을 전달하는 대신, `setNumber(n => n +1)`와 같이 큐의 이전 state를 기반으로 다음 state를 계산하는 함수를 전달할 수 있습니다. 이는 단순히 state 값을 대체하는 것이 아니라 React에게 "state 값으로 무언가를 하라"고 지시하는 방법입니다.

`n => n + 1`는 **업데이터 함수(updater function)**라고 부릅니다. 이를 state 설정자 함수에 전달할 때:

1. React는 이벤트 핸들러의 다른 코드가 모두 실행된 후에 이 함수가 처리되도록 큐에 넣습니다.
2. 다음 렌더링 중에 React는 큐를 순회하여 최종 업데이트된 state를 제공합니다.
