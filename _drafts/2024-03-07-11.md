---
title: 리액트 - Effect 동기화하기, Effect가 필요하지 않을 수도 있습니다
date: 2024-03-07 00:00:00 +09:00
categories: [프론트엔드, 리액트]
tags: [프론트엔드, 리액트]
---

## Effect

### Effect란 무엇이며 이벤트와는 어떤게 다른가요?

- **렌더링 코드**는 컴포넌트 최상위 레벨에 있습니다. 여기서 props와 state를 가져와 변환하고 화면에 표시할 JSX를 반환합니다. 렌더링 코드는 순수해야합니다. 수학 공식처럼 결과만 계산할 뿐 다른 작업은 수행하지 않습니다.
- **이벤트 핸들러**는 컴포넌트 내부에 중첩된 함수로, 계산만 하는 게 아니라 별도의 작업도 수행합니다.

**Effect를 사용하면 특정 이벤트가 아닌 렌더링 자체로 인해 발생하는 사이드 이펙트를 명시할 수 있습니다.** 채팅에서 메시지를 보내는 것은 사용자가 특정 버튼을 클릭함으로써 직접적으로 발생하기 때문에 이벤트다. 그러나 서버 연결을 설정하는 것은 컴포넌트를 표시하게 만든 상호작용에 관계없이 발생하기 때문에 하나의 Effect이다. Effect는 화면 업데이트 후 커밋이 끝날 때 실행된다. 이 때가 React 컴포넌트를 일부 외부 시스템과 동기화하기에 좋은 타이밍입니다.

### Effect 작성 방법

1. Effect를 선언합니다.
2. Effect의 의존성을 명시합니다.
3. 필요한 경우 클린업을 명시합니다.

### Step1: Effect를 선언하세요

```
function MyComponent() {
  useEffect(() => {
    // 여기의 코드는 매 렌더링 후에 실행됩니다.
  });
}
```

컴포넌트가 렌더링될 때마다 React는 화면을 업데이트하고 `useEffect` 내부의 코드를 실행합니다. 즉, **`useEffect`는 해당 렌더링이 화면에 반영이 될 때까지 코드를 실행하는 것을 "지연"시킵니다.**

기본적으로 Effect는 매번 렌더링 후에 실행됩니다. 그렇기 때문에 다음과 같은 코드는 **무한 루프를 생성합니다.**

```
const [count, setCount] = useState(0);
useEffect(()=> {
  setCount(count + 1);
});
```

Effect는 렌더링의 결과로 실행됩니다. state를 설정하면 렌더링이 트리거됩니다. Effect에서 즉시 state를 설정하는 것은 전원 콘센트를 다시 꽂는 것과 같습니다. Effect가 실행되고, state를 설정하면 다시 렌더링이 발생하고, 다시 렌더링이 발생하면 Effect가 실행되고 하는 식입니다.

Effect는 보통 컴포넌트를 외부 시스템과 동기화해야 합니다. 외부 시스템이 없고 다른 state를 기반으로 일부 state만 조정하려는 경우 Effect가 필요하지 않을 수도 있습니다.

### Step2: Effect 의존성을 지정하세요

기본적으로 Effect는 매번 렌더링 후에 실행됩니다. 하지만 이를 **원하지 않는** 경우가 있습니다.
useEffect 호출의 두 번째 인자로 의존성 배열을 지정하여 React가 **불필요하게 Effect를 다시 실행하지 않도록 지시할 수 있습니다.**

```
useEffect(() => {
  // ...
}, []);
```

의존성 배열은 여러 개의 의존성을 포함할 수 있습니다. React는 지정한 모든 의존성의 값이 이전 렌더링 때와 정확히 동일한 경우에만 Effect의 재실행을 건너뜁니다.
의존성을 "선택"할 수 없다는 점에 유의하세요. 의존성은 Effect 내부의 코드에 의해 결정됩니다.

의존성 배열이 없는 경우와 비어 있는 `[]` 의존성 배열이 있는 경우의 동작은 다릅니다.

```
useEffect(() => {
  // 렌더시마다 실행됩니다.
});

useEffect(() => {
  // 오직 마운트시(컴포넌트가 나타날 때)에만 실행됩니다.
}, []);

useEffect(() => {
  // 마운트시 뿐만 아니라 a 또는 b가 직전 렌더와 달라졌을 때에도 실행됩니다.
},[a, b]);
```

**마운트 될 때는 화면에서 처음 나타낼 때를 말하는 것!!**

- Strict 모드에서 React는 컴포넌트를 두 번 마운트하여(개발중인 경우에만!) Effect를 스트레스 테스트합니다.
- 다시 마운트를 수행함으로 인해 Effect가 깨지는 경우, 클린업 함수를 구현해야 합니다.
- React는 다음 Effect가 실행되기 전 마운트 해제 시점에 클린업 함수를 호출합니다.

## 불필요한 Effect를 제거하는 방법

**렌더링을 위해 데이터를 변환하는 경우 Effect는 필요하지 않습니다.** 예를 들어, 목록을 표시하기 전에 필터링하고 싶다고 가정. 목록이 변경될 때 state 변수를 업데이트하는 Effect를 작성하고 싶을 수 있다. 하지만 이는 비효율적입니다. 컴포넌트는 state를 업데이트할 때 React는 먼저 컴포넌트 함수를 호출해 화면에 표시될 내용를 계산합니다. 다음으로 이러한 변경 사항을 DOM에 "commit"하여 화면을 업데이트하고, 그 후에 Effect를 실행합니다. 만약 Effect "또한" state를 즉시 업데이트한다면, 이로 인해 전체 프로세스가 처음부터 다시 시작될 것입니다! 불필요한 렌더링을 피하려면 모든 데이터 변환을 컴포넌트 최상위 레벨에서 하세요. 그러면 props나 state가 변경될 때마다 해당 코드가 자동으로 다시 실행될 것입니다.

**사용자 이벤트를 처리하는 데에 Effect는 필요하지 않습니다.**

한편 외부 시스템과 동기화화려면 Effect가 필요합니다.

- 비용이 많이 드는 계산을 캐시하려면 `useEffect` 대신 `useMemo`를 추가하세요.
- 전체 컴포넌트 트리의 state를 재설정하려면 다른 `key`를 전달하세요.
- props 변경에 대한 응답으로 특정 state 일부를 조정하려면 렌더링 중에 설정하세요. -컴포넌트가 표시될 때 실행되는 코드는 Effects에 있어야 하며, 나머지는 이벤트(Events)에 있어야 합니다.
- 여러 컴포넌트의 state를 업데이트해야 하는 경우 단일 이벤트에서 처리하는 것이 좋습니다.
- 여러 컴포넌트에서 state 변수를 동기화하려고 할 때마다 state 끌어올리기를 고려하세요.
- Effect로 데이터를 페치할 수 있지만, 경쟁 조건을 피하기 위해 클린업 로직을 구현해야 합니다.
